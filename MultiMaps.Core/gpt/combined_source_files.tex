
\documentclass[12pt]{article}
\usepackage[margin=1in,paperwidth=8.5in,paperheight=11in]{geometry}
\usepackage[T1]{fontenc}
\usepackage[scaled=0.85]{beramono}  % Clean monospaced font
\renewcommand{\familydefault}{\ttdefault}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{needspace}  % For \Needspace to avoid splitting chunks

% No page numbers:
\pagestyle{empty}

% Code listing settings (no line numbers):
\lstset{
  basicstyle=\fontsize{14}{20}\selectfont\ttfamily,
  breaklines=true,
  showstringspaces=false,
  tabsize=2
}

\begin{document}

\Needspace{225\baselineskip}
\begin{lstlisting}[language=Java]

=== File: ../Bucket.cs ===
namespace MultiMaps.Core;

internal class Bucket<TKey, TValue>
{
    public Entry<TKey, TValue>? Head { get; set; }
}


=== File: ../Entry.cs ===
namespace MultiMaps.Core;

internal class Entry<TKey, TValue>
{
    public TKey Key { get; }
    public List<TValue> Values { get; }
    public Entry<TKey, TValue>? Next { get; set; }

    public Entry(TKey key)
    {
        Key = key;
        Values = new List<TValue>();
    }
}

=== File: ../MultiMaps.Core.csproj ===
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

</Project>


=== File: ../MultiValueDictionary.cs ===
namespace MultiMaps.Core;

public class MultiValueDictionary<TKey, TValue>
{
    private const int DefaultCapacity = 64;
    private const float LoadFactorThreshold = 0.75f;

    private Bucket<TKey, TValue>[] _buckets;
    private int _count;

    public MultiValueDictionary(int capacity)
    {
        _buckets = new Bucket<TKey, TValue>[capacity];
    }

    public MultiValueDictionary() : this(DefaultCapacity) { }

    public void Add(TKey key, TValue value)
    {
        if (key == null)
            throw new ArgumentNullException(nameof(key));

        EnsureCapacity();

        int index = GetIndex(key);
        Bucket<TKey, TValue> bucket;
        if (_buckets[index] == null)
        {
            _buckets[index] = new Bucket<TKey, TValue>();
        }
        bucket = _buckets[index];

        var entry = FindEntry(bucket, key);
        if (entry == null)
        {
            entry = new Entry<TKey, TValue>(key);
            entry.Values.Add(value);
            entry.Next = bucket.Head;
            bucket.Head = entry;

            _count++;
        }
        else
        {
            entry.Values.Add(value);
        }
    }

    public IReadOnlyCollection<TValue> GetValues(TKey key)
    {
        if (key == null)
            throw new ArgumentNullException(nameof(key));

        int index = GetIndex(key);
        var bucket = _buckets[index];
        if (bucket == null) return Array.Empty<TValue>();

        var entry = FindEntry(bucket, key);
        if (entry == null)
        {
            return Array.Empty<TValue>();
        }
        else
        {
            return entry.Values.AsReadOnly();
        }
    }

    public bool RemoveValue(TKey key, TValue value)
    {
        if (key == null)
            throw new ArgumentNullException(nameof(key));

        int index = GetIndex(key);
        var bucket = _buckets[index];
        if (bucket == null) return false;

        var entry = FindEntry(bucket, key);
        if (entry == null) return false;

        bool removed = entry.Values.Remove(value);

        if (removed && entry.Values.Count == 0)
        {
            RemoveKeyInternal(bucket, key);
        }

        return removed;
    }

    public bool RemoveKey(TKey key)
    {
        if (key == null)
            throw new ArgumentNullException(nameof(key));

        int index = GetIndex(key);
        var bucket = _buckets[index];
        if (bucket == null) return false;

        return RemoveKeyInternal(bucket, key);
    }

    private void EnsureCapacity()
    {
        float loadFactor = (float)_count / _buckets.Length;
        if (loadFactor >= LoadFactorThreshold)
        {
            Resize(_buckets.Length * 2);
        }
    }

    private void Resize(int newCapacity)
    {
        var oldBuckets = _buckets;
        _buckets = new Bucket<TKey, TValue>[newCapacity];
        _count = 0;

        foreach (var bucket in oldBuckets)
        {
            if (bucket == null) continue;

            var entry = bucket.Head;
            while (entry != null)
            {
                foreach (var value in entry.Values)
                {
                    Add(entry.Key, value);
                }

                entry = entry.Next;
            }
        }
    }

    private int GetIndex(TKey key)
    {
        return Math.Abs(key!.GetHashCode()) % _buckets.Length;
    }

    private Entry<TKey, TValue>? FindEntry(Bucket<TKey, TValue> bucket, TKey key)
    {
        var current = bucket.Head;
        while (current != null)
        {
            if (current.Key!.Equals(key))
            {
                return current;
            }

            current = current.Next;
        }
        return null;
    }

    private bool RemoveKeyInternal(Bucket<TKey, TValue> bucket, TKey key)
    {
        Entry<TKey, TValue>? previous = null;
        var current = bucket.Head;

        while (current != null)
        {
            if (current.Key!.Equals(key))
            {
                if (previous == null)
                {
                    bucket.Head = current.Next;
                }
                else
                {
                    previous.Next = current.Next;
                }

                _count--;
                return true;
            }

            previous = current;
            current = current.Next;
        }

        return false;
    }
}

\end{lstlisting}



\end{document}
