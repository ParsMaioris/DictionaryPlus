
\documentclass[12pt]{article}
\usepackage[margin=1in,paperwidth=8.5in,paperheight=11in]{geometry}
\usepackage[T1]{fontenc}
\usepackage[scaled=0.85]{beramono}  % Clean monospaced font
\renewcommand{\familydefault}{\ttdefault}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{needspace}  % For \Needspace to avoid splitting chunks

% No page numbers:
\pagestyle{empty}

% Code listing settings (no line numbers):
\lstset{
  basicstyle=\fontsize{14}{20}\selectfont\ttfamily,
  breaklines=true,
  showstringspaces=false,
  tabsize=2
}

\begin{document}

\Needspace{336\baselineskip}
\begin{lstlisting}[language=Java]

=== File: ../Bucket.cs ===
namespace MultiMaps.Core;

internal class Bucket<TKey, TValue>
{
    public Entry<TKey, TValue>? Head { get; set; }
}


=== File: ../Entry.cs ===
namespace MultiMaps.Core;

internal class Entry<TKey, TValue>
{
    public TKey Key { get; }
    public List<TValue> Values { get; }
    public Entry<TKey, TValue>? Next { get; set; }

    public Entry(TKey key)
    {
        Key = key;
        Values = new List<TValue>();
    }
}

=== File: ../MultiMaps.Core.csproj ===
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

</Project>


=== File: ../MultiValueDictionary.cs ===
using System.Collections;

namespace MultiMaps.Core;

public class MultiValueDictionary<TKey, TValue> : IEnumerable<KeyValuePair<TKey, TValue>>
{
    private const int DefaultCapacity = 64;
    private const float LoadFactorThreshold = 0.75f;

    internal Bucket<TKey, TValue>[] Buckets;
    internal int Count;
    internal int Version;

    public MultiValueDictionary(int capacity)
    {
        Buckets = new Bucket<TKey, TValue>[capacity];
    }

    public MultiValueDictionary() : this(DefaultCapacity) { }

    public void Add(TKey key, TValue value)
    {
        if (key == null)
            throw new ArgumentNullException(nameof(key));

        EnsureCapacity();

        int index = GetIndex(key);
        Bucket<TKey, TValue> bucket;
        if (Buckets[index] == null)
        {
            Buckets[index] = new Bucket<TKey, TValue>();
        }
        bucket = Buckets[index];

        var entry = FindEntry(bucket, key);
        if (entry == null)
        {
            entry = new Entry<TKey, TValue>(key);
            entry.Values.Add(value);
            entry.Next = bucket.Head;
            bucket.Head = entry;

            Count++;
            Version++;
        }
        else
        {
            entry.Values.Add(value);
            Version++;
        }
    }

    public IReadOnlyCollection<TValue> GetValues(TKey key)
    {
        if (key == null)
            throw new ArgumentNullException(nameof(key));

        int index = GetIndex(key);
        var bucket = Buckets[index];
        if (bucket == null) return Array.Empty<TValue>();

        var entry = FindEntry(bucket, key);
        if (entry == null)
        {
            return Array.Empty<TValue>();
        }
        else
        {
            return entry.Values.AsReadOnly();
        }
    }

    public bool RemoveValue(TKey key, TValue value)
    {
        if (key == null)
            throw new ArgumentNullException(nameof(key));

        int index = GetIndex(key);
        var bucket = Buckets[index];
        if (bucket == null) return false;

        var entry = FindEntry(bucket, key);
        if (entry == null) return false;

        bool removed = entry.Values.Remove(value);
        if (removed)
        {
            Version++;
            if (entry.Values.Count == 0)
            {
                RemoveKeyInternal(bucket, key);
            }
        }
        return removed;
    }

    public bool RemoveKey(TKey key)
    {
        if (key == null)
            throw new ArgumentNullException(nameof(key));

        int index = GetIndex(key);
        var bucket = Buckets[index];
        if (bucket == null) return false;

        return RemoveKeyInternal(bucket, key);
    }

    public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator()
    {
        return new MultiValueDictionaryEnumerator<TKey, TValue>(this);
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }

    private void EnsureCapacity()
    {
        float loadFactor = (float)Count / Buckets.Length;
        if (loadFactor >= LoadFactorThreshold)
        {
            Resize(Buckets.Length * 2);
        }
    }

    private void Resize(int newCapacity)
    {
        var oldBuckets = Buckets;
        Buckets = new Bucket<TKey, TValue>[newCapacity];
        Count = 0;
        Version++;

        foreach (var bucket in oldBuckets)
        {
            if (bucket == null) continue;

            var entry = bucket.Head;
            while (entry != null)
            {
                foreach (var value in entry.Values)
                {
                    Add(entry.Key, value);
                }

                entry = entry.Next;
            }
        }
    }

    private int GetIndex(TKey key)
    {
        return Math.Abs(key!.GetHashCode()) % Buckets.Length;
    }

    private Entry<TKey, TValue>? FindEntry(Bucket<TKey, TValue> bucket, TKey key)
    {
        var current = bucket.Head;
        while (current != null)
        {
            if (current.Key!.Equals(key))
            {
                return current;
            }

            current = current.Next;
        }
        return null;
    }

    private bool RemoveKeyInternal(Bucket<TKey, TValue> bucket, TKey key)
    {
        Entry<TKey, TValue>? previous = null;
        var current = bucket.Head;

        while (current != null)
        {
            if (current.Key!.Equals(key))
            {
                if (previous == null)
                {
                    bucket.Head = current.Next;
                }
                else
                {
                    previous.Next = current.Next;
                }

                Count--;
                Version++;
                return true;
            }
            previous = current;
            current = current.Next;
        }
        return false;
    }
}

=== File: ../MultiValueDictionaryEnumerator.cs ===
namespace MultiMaps.Core;

internal class MultiValueDictionaryEnumerator<TKey, TValue> : IEnumerator<KeyValuePair<TKey, TValue>>
{
    private readonly MultiValueDictionary<TKey, TValue> _dictionary;
    private int _version;
    private int _bucketIndex;
    private Entry<TKey, TValue>? _currentEntry;
    private int _valueIndex;
    private KeyValuePair<TKey, TValue>? _currentPair;

    public MultiValueDictionaryEnumerator(MultiValueDictionary<TKey, TValue> dictionary)
    {
        _dictionary = dictionary;
        _version = dictionary.Version;
        _bucketIndex = -1;
        _currentEntry = null;
        _valueIndex = -1;
        _currentPair = null;
    }

    public KeyValuePair<TKey, TValue> Current()
    {
        if (_currentPair == null)
            throw new InvalidOperationException("Enumeration not started or has ended.");

        return _currentPair.Value;
    }

    KeyValuePair<TKey, TValue> IEnumerator<KeyValuePair<TKey, TValue>>.Current => Current();

    object System.Collections.IEnumerator.Current => Current();

    public bool MoveNext()
    {
        if (_version != _dictionary.Version)
            throw new InvalidOperationException("Collection was modified during iteration");

        if (_currentEntry != null && _valueIndex < _currentEntry.Values.Count - 1)
        {
            _valueIndex++;
            _currentPair = new KeyValuePair<TKey, TValue>(
                _currentEntry.Key,
                _currentEntry.Values[_valueIndex]);
            return true;
        }

        if (_currentEntry != null && _currentEntry.Next != null)
        {
            _currentEntry = _currentEntry.Next;
            _valueIndex = 0;
            if (_currentEntry.Values.Count > 0)
            {
                _currentPair = new KeyValuePair<TKey, TValue>(
                    _currentEntry.Key,
                    _currentEntry.Values[_valueIndex]);
                return true;
            }
        }

        while (++_bucketIndex < _dictionary.Buckets.Length)
        {
            var bucket = _dictionary.Buckets[_bucketIndex];
            if (bucket == null || bucket.Head == null)
                continue;

            _currentEntry = bucket.Head;
            _valueIndex = 0;

            if (_currentEntry.Values.Count > 0)
            {
                _currentPair = new KeyValuePair<TKey, TValue>(
                    _currentEntry.Key,
                    _currentEntry.Values[_valueIndex]);
                return true;
            }
        }

        _currentPair = null;
        return false;
    }

    public void Reset()
    {
        if (_version != _dictionary.Version)
            throw new InvalidOperationException("Collection was modified during iteration");

        _bucketIndex = -1;
        _currentEntry = null;
        _valueIndex = -1;
        _currentPair = null;
    }

\end{lstlisting}

\Needspace{3\baselineskip}
\begin{lstlisting}[language=Java]
    public void Dispose() { }
\end{lstlisting}

\Needspace{5\baselineskip}
\begin{lstlisting}[language=Java]
}


\end{lstlisting}



\end{document}
